
//from deepseek copy - paste 


// Simple MESI Cache Coherency Protocol
// 2-core system with directory-based coherency

module mesi_cache(
    input wire clk,
    input wire reset,
    
    // Core 1 interface
    input wire core1_req,           // 1=request, 0=idle
    input wire core1_rw,            // 1=write, 0=read  
    input wire [7:0] core1_addr,    // Memory address
    output reg core1_ready,         // 1=operation complete
    output reg [31:0] core1_data,   // Read data
    
    // Core 2 interface
    input wire core2_req,
    input wire core2_rw,
    input wire [7:0] core2_addr,
    output reg core2_ready,
    output reg [31:0] core2_data,
    
    // Memory interface
    output reg mem_read,
    output reg mem_write,
    output reg [7:0] mem_addr,
    input wire [31:0] mem_data_in,
    output reg [31:0] mem_data_out
);

// MESI States
localparam [1:0] I = 2'b00,  // Invalid
                 S = 2'b01,  // Shared
                 E = 2'b10,  // Exclusive
                 M = 2'b11;  // Modified

// Cache line structure
reg [31:0] cache_data [0:1][0:3];  // [core][line] data
reg [7:0] cache_tag [0:1][0:3];    // [core][line] tag
reg [1:0] cache_state [0:1][0:3];  // [core][line] MESI state
reg valid [0:1][0:3];              // [core][line] valid bit

// Directory - tracks who has what
reg [1:0] dir_state [0:63];        // Memory block state
reg dir_owner [0:63];              // Which core owns it (0 or 1)
reg dir_shared [0:63];             // Is it shared?

// Internal signals
reg [1:0] current_core;
reg [7:0] current_addr;
reg current_rw;
reg operation_active;

// Cache controller state machine
reg [2:0] state;
localparam IDLE = 3'b000,
           CHECK_CACHE = 3'b001,
           SEND_REQUEST = 3'b010,
           WAIT_RESPONSE = 3'b011,
           UPDATE_CACHE = 3'b100,
           INVALIDATE = 3'b101;

// Main state machine
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        core1_ready <= 0;
        core2_ready <= 0;
        operation_active <= 0;
        
        // Initialize cache states to Invalid
        for (integer i = 0; i < 2; i = i + 1) begin
            for (integer j = 0; j < 4; j = j + 1) begin
                cache_state[i][j] <= I;
                valid[i][j] <= 0;
            end
        end
        
        // Initialize directory
        for (integer i = 0; i < 64; i = i + 1) begin
            dir_state[i] <= E;  // Start as Exclusive in memory
            dir_owner[i] <= 0;
            dir_shared[i] <= 0;
        end
    end else begin
        case (state)
            IDLE: begin
                core1_ready <= 0;
                core2_ready <= 0;
                
                // Check if any core has request
                if (core1_req && !operation_active) begin
                    current_core <= 0;
                    current_addr <= core1_addr;
                    current_rw <= core1_rw;
                    operation_active <= 1;
                    state <= CHECK_CACHE;
                end else if (core2_req && !operation_active) begin
                    current_core <= 1;
                    current_addr <= core2_addr;
                    current_rw <= core2_rw;
                    operation_active <= 1;
                    state <= CHECK_CACHE;
                end
            end
            
            CHECK_CACHE: begin
                // Check if we have the data in cache
                if (cache_hit(current_core, current_addr)) begin
                    // Cache hit - check if we can proceed
                    if (can_access(current_core, current_addr, current_rw)) begin
                        state <= UPDATE_CACHE;
                    end else begin
                        state <= SEND_REQUEST;
                    end
                end else begin
                    // Cache miss
                    state <= SEND_REQUEST;
                end
            end
            
            SEND_REQUEST: begin
                // Send request to directory/memory
                mem_addr <= current_addr;
                
                if (current_rw) begin
                    // Write request - need exclusive access
                    mem_write <= 1;
                    state <= WAIT_RESPONSE;
                end else begin
                    // Read request
                    mem_read <= 1;
                    state <= WAIT_RESPONSE;
                end
            end
            
            WAIT_RESPONSE: begin
                mem_read <= 0;
                mem_write <= 0;
                
                // Simulate memory/directory response
                if (current_rw) begin
                    // For write: get data from core and update
                    mem_data_out <= (current_core == 0) ? core1_data : core2_data;
                    state <= UPDATE_CACHE;
                end else begin
                    // For read: get data from memory
                    if (current_core == 0)
                        core1_data <= mem_data_in;
                    else
                        core2_data <= mem_data_in;
                    state <= UPDATE_CACHE;
                end
            end
            
            UPDATE_CACHE: begin
                // Update cache state and data
                update_cache_line(current_core, current_addr, current_rw);
                
                // Invalidate other cores if we got exclusive access
                if (current_rw || cache_state[current_core][get_index(current_addr)] == E) begin
                    invalidate_other_cores(current_core, current_addr);
                end
                
                state <= INVALIDATE;
            end
            
            INVALIDATE: begin
                // Mark operation complete
                if (current_core == 0)
                    core1_ready <= 1;
                else
                    core2_ready <= 1;
                
                operation_active <= 0;
                state <= IDLE;
            end
        endcase
    end
end

// Helper function: Check cache hit
function cache_hit;
    input [1:0] core;
    input [7:0] addr;
    integer index;
    begin
        index = get_index(addr);
        cache_hit = valid[core][index] && (cache_tag[core][index] == get_tag(addr));
    end
endfunction

// Helper function: Check access permissions
function can_access;
    input [1:0] core;
    input [7:0] addr;
    input rw;
    integer index;
    reg [1:0] state;
    begin
        index = get_index(addr);
        state = cache_state[core][index];
        
        if (rw) begin
            // Write requires Modified or Exclusive state
            can_access = (state == M) || (state == E);
        end else begin
            // Read requires any valid state
            can_access = (state != I);
        end
    end
endfunction

// Update cache line
task update_cache_line;
    input [1:0] core;
    input [7:0] addr;
    input rw;
    integer index;
    begin
        index = get_index(addr);
        valid[core][index] <= 1;
        cache_tag[core][index] <= get_tag(addr);
        
        if (rw) begin
            // Write operation - go to Modified state
            cache_state[core][index] <= M;
            if (core == 0)
                cache_data[core][index] <= core1_data;
            else
                cache_data[core][index] <= core2_data;
        end else begin
            // Read operation
            if (dir_shared[get_block(addr)]) begin
                cache_state[core][index] <= S;  // Shared
            end else begin
                cache_state[core][index] <= E;  // Exclusive
            end
            cache_data[core][index] <= mem_data_in;
        end
        
        // Update directory
        dir_owner[get_block(addr)] <= core;
        if (rw) begin
            dir_state[get_block(addr)] <= M;
            dir_shared[get_block(addr)] <= 0;
        end else begin
            if (dir_state[get_block(addr)] == E) begin
                dir_state[get_block(addr)] <= S;
                dir_shared[get_block(addr)] <= 1;
            end
        end
    end
endtask

// Invalidate other cores' copies
task invalidate_other_cores;
    input [1:0] core;
    input [7:0] addr;
    integer index, other_core;
    begin
        other_core = (core == 0) ? 1 : 0;
        index = get_index(addr);
        
        if (valid[other_core][index] && cache_tag[other_core][index] == get_tag(addr)) begin
            cache_state[other_core][index] <= I;
            $display("Time %0t: Invalidated core %0d cache line for addr %h", 
                     $time, other_core, addr);
        end
    end
endtask

// Address decomposition functions
function [3:0] get_index;
    input [7:0] addr;
    get_index = addr[3:0];  // 4-bit index (16 cache lines total)
endfunction

function [3:0] get_tag;
    input [7:0] addr;
    get_tag = addr[7:4];    // 4-bit tag
endfunction

function [5:0] get_block;
    input [7:0] addr;
    get_block = addr[7:2];  // 6-bit block address (64 blocks)
endfunction

// Display cache state for debugging
always @(posedge clk) begin
    if (operation_active) begin
        $display("Time %0t: Core %0d %s addr %h, State: %s", 
                 $time, current_core, 
                 current_rw ? "WRITE" : "READ", 
                 current_addr,
                 cache_state_to_string(cache_state[current_core][get_index(current_addr)]));
    end
end

// Convert state to string for display
function string cache_state_to_string;
    input [1:0] state;
    begin
        case (state)
            I: cache_state_to_string = "Invalid";
            S: cache_state_to_string = "Shared";
            E: cache_state_to_string = "Exclusive";
            M: cache_state_to_string = "Modified";
            default: cache_state_to_string = "Unknown";
        endcase
    end
endfunction

endmodule